// generated by pbpg, do not modify

package main

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

type CalcData struct{}

func main() {
	tokens := strings.Fields(os.Args[1])
	result, err := ParseCalc(tokens, nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(result)
}

// Expression = Term { AddOp Term }
func (p *CalcParser) stateExpression() (int, error) {
	var err error
	var ret int
	var v1 int
	var v2temp string
	var v2 []string
	var v3temp int
	var v3 []int
	v1, err = p.stateTerm()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2temp, err = p.stateAddOp()
			if err == nil {
				v3temp, err = p.stateTerm()
			}
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionExpression(v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionExpression(v1 int, v2 []string, v3 []int) int {
	r := v1
	for i, v := range v2 {
		switch v {
		case "+":
			r = r + v3[i]
		case "-":
			r = r - v3[i]
		}
	}

	return r

}

// Term = Factor { MultOp Factor }
func (p *CalcParser) stateTerm() (int, error) {
	var err error
	var ret int
	var v1 int
	var v2temp string
	var v2 []string
	var v3temp int
	var v3 []int
	v1, err = p.stateFactor()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2temp, err = p.stateMultOp()
			if err == nil {
				v3temp, err = p.stateFactor()
			}
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionTerm(v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionTerm(v1 int, v2 []string, v3 []int) int {
	r := v1
	for i, v := range v2 {
		switch v {
		case "*":
			r = r * v3[i]
		case "/":
			r = r / v3[i]
		}
	}
	return r

}

// Factor = ( "(" Expression ")" ) | Number
func (p *CalcParser) stateFactor() (int, error) {
	var err error
	var ret int
	var a1Pos int
	var v1 string
	var v2 int
	var v3 string
	var v4 int
	a1Pos = 1
	// group
	p = p.predict()
	v1, err = p.literal("(")
	if err == nil {
		v2, err = p.stateExpression()
		if err == nil {
			v3, err = p.literal(")")
		}
	}
	if err != nil {
		p = p.backtrack()
	} else {
		p = p.accept()
	}
	if err != nil {
		a1Pos = 2
		v4, err = p.stateNumber()
	}
	if err == nil {
		ret = p.Data.actionFactor(a1Pos, v1, v2, v3, v4)
	}

	return ret, err
}

func (p *CalcData) actionFactor(a1Pos int, v1 string, v2 int, v3 string, v4 int) int {
	var r int
	switch a1Pos {
	case 1:
		r = v2
	case 2:
		r = v4
	}
	return r

}

// AddOp = "+" | "-"
func (p *CalcParser) stateAddOp() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	a1Pos = 1
	v1, err = p.literal("+")
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("-")
	}
	if err == nil {
		ret = p.Data.actionAddOp(a1Pos, v1, v2)
	}

	return ret, err
}

func (p *CalcData) actionAddOp(a1Pos int, v1 string, v2 string) string {
	var r string
	switch a1Pos {
	case 1:
		r = v1
	case 2:
		r = v2
	}
	return r

}

// MultOp = "*" | "/"
func (p *CalcParser) stateMultOp() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	a1Pos = 1
	v1, err = p.literal("*")
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("/")
	}
	if err == nil {
		ret = p.Data.actionMultOp(a1Pos, v1, v2)
	}

	return ret, err
}

func (p *CalcData) actionMultOp(a1Pos int, v1 string, v2 string) string {
	var r string
	switch a1Pos {
	case 1:
		r = v1
	case 2:
		r = v2
	}
	return r

}

// Number = [ Neg ] Digit { Digit }
func (p *CalcParser) stateNumber() (int, error) {
	var err error
	var ret int
	var v1 string
	var v2 string
	var v3temp string
	var v3 []string
	// option
	p = p.predict()
	v1, err = p.stateNeg()
	if err != nil {
		p = p.backtrack()
		p.lastErr = err
		err = nil
	} else {
		p = p.accept()
	}
	if err == nil {
		v2, err = p.stateDigit()
		if err == nil {
			// repetition
			for {
				p = p.predict()
				v3temp, err = p.stateDigit()
				if err != nil {
					p = p.backtrack()
					p.lastErr = err
					err = nil
					break
				} else {
					v3 = append(v3, v3temp)
					p = p.accept()
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionNumber(v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionNumber(v1 string, v2 string, v3 []string) int {
	stringNumber := v1 + v2 + strings.Join(v3, "")
	num, _ := strconv.Atoi(stringNumber)
	return num

}

// Neg = "-"
func (p *CalcParser) stateNeg() (string, error) {
	var err error
	var ret string
	var v1 string
	v1, err = p.literal("-")
	if err == nil {
		ret = p.Data.actionNeg(v1)
	}

	return ret, err
}

func (p *CalcData) actionNeg(v1 string) string {
	return v1
}

// Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
func (p *CalcParser) stateDigit() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	var v3 string
	var v4 string
	var v5 string
	var v6 string
	var v7 string
	var v8 string
	var v9 string
	var v10 string
	a1Pos = 1
	v1, err = p.literal("0")
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("1")
		if err != nil {
			a1Pos = 3
			v3, err = p.literal("2")
			if err != nil {
				a1Pos = 4
				v4, err = p.literal("3")
				if err != nil {
					a1Pos = 5
					v5, err = p.literal("4")
					if err != nil {
						a1Pos = 6
						v6, err = p.literal("5")
						if err != nil {
							a1Pos = 7
							v7, err = p.literal("6")
							if err != nil {
								a1Pos = 8
								v8, err = p.literal("7")
								if err != nil {
									a1Pos = 9
									v9, err = p.literal("8")
									if err != nil {
										a1Pos = 10
										v10, err = p.literal("9")
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionDigit(a1Pos, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10)
	}

	return ret, err
}

func (p *CalcData) actionDigit(a1Pos int, v1 string, v2 string, v3 string, v4 string, v5 string, v6 string, v7 string, v8 string, v9 string, v10 string) string {
	return fmt.Sprintf("%v", a1Pos-1)
}

func ParseCalc(input []string, data *CalcData) (int, error) {
	p := newCalcParser(input, data)

	ret, err := p.stateExpression()
	if err == nil {
		if p.pos < len(p.input) {
			return ret, p.lastErr
		}
	}

	return ret, err
}

type CalcParser struct {
	input   []string
	pos     int
	Data    *CalcData
	lastErr error

	predictStack []*CalcParser
}

func newCalcParser(input []string, data *CalcData) *CalcParser {
	return &CalcParser{
		input: input,
		Data:  data,
	}
}

func (p *CalcParser) position() int {
	return p.pos
}

func (p *CalcParser) literal(want string) (string, error) {
	if p.pos >= len(p.input) {
		return "", fmt.Errorf("EOF")
	}
	if p.input[p.pos] == want {
		p.pos++
		return want, nil
	}

	return "", fmt.Errorf("%v: expected \"%v\"", p.position(), want)
}

func (p *CalcParser) predict() *CalcParser {
	p.predictStack = append(p.predictStack, p)
	return &CalcParser{
		input:        p.input,
		pos:          p.pos,
		predictStack: p.predictStack,
		lastErr:      p.lastErr,
		Data:         p.Data,
	}
}

func (p *CalcParser) backtrack() *CalcParser {
	pp := p.predictStack[len(p.predictStack)-1]
	pp.predictStack = pp.predictStack[:len(pp.predictStack)-1]
	pp.lastErr = p.lastErr
	return pp
}

func (p *CalcParser) accept() *CalcParser {
	pp := p.backtrack()
	pp.pos = p.pos
	return pp
}
