// generated by pbpg, do not modify

package main

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

type CalcData struct{}

func main() {
	result, err := ParseCalc(os.Args[1], nil)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(result)
}

// Expression = Term { AddOp Term }
func (p *CalcParser) stateExpression() (int, error) {
	var err error
	var ret int
	var v1 int
	var v2temp string
	var v2 []string
	var v3temp int
	var v3 []int
	v1, err = p.stateTerm()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2temp, err = p.stateAddOp()
			if err == nil {
				v3temp, err = p.stateTerm()
			}
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionExpression(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionExpression(pos int, v1 int, v2 []string, v3 []int) int {
	r := v1
	for i, v := range v2 {
		switch v {
		case "+":
			r = r + v3[i]
		case "-":
			r = r - v3[i]
		}
	}

	return r

}

// Term = Factor { MultOp Factor }
func (p *CalcParser) stateTerm() (int, error) {
	var err error
	var ret int
	var v1 int
	var v2temp string
	var v2 []string
	var v3temp int
	var v3 []int
	v1, err = p.stateFactor()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2temp, err = p.stateMultOp()
			if err == nil {
				v3temp, err = p.stateFactor()
			}
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionTerm(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionTerm(pos int, v1 int, v2 []string, v3 []int) int {
	r := v1
	for i, v := range v2 {
		switch v {
		case "*":
			r = r * v3[i]
		case "/":
			r = r / v3[i]
		}
	}
	return r

}

// Factor = ( "(" Expression ")" ) | Number
func (p *CalcParser) stateFactor() (int, error) {
	var err error
	var ret int
	var a1Pos int
	var v1 string
	var v2 int
	var v3 string
	var v4 int
	a1Pos = 1
	// group
	p = p.predict()
	v1, err = p.literal("(")
	if err == nil {
		v2, err = p.stateExpression()
		if err == nil {
			v3, err = p.literal(")")
		}
	}
	if err != nil {
		p = p.backtrack()
	} else {
		p = p.accept()
	}
	if err != nil {
		a1Pos = 2
		v4, err = p.stateNumber()
		if err != nil {
			a1Pos = -1
		}
	}
	if err == nil {
		ret = p.Data.actionFactor(p.pos, a1Pos, v1, v2, v3, v4)
	}

	return ret, err
}

func (p *CalcData) actionFactor(pos int, a1Pos int, v1 string, v2 int, v3 string, v4 int) int {
	var r int
	switch a1Pos {
	case 1:
		r = v2
	case 2:
		r = v4
	}
	return r

}

// AddOp = "+" | "-"
func (p *CalcParser) stateAddOp() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	a1Pos = 1
	v1, err = p.literal("+")
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("-")
		if err != nil {
			a1Pos = -1
		}
	}
	if err == nil {
		ret = p.Data.actionAddOp(p.pos, a1Pos, v1, v2)
	}

	return ret, err
}

func (p *CalcData) actionAddOp(pos int, a1Pos int, v1 string, v2 string) string {
	var r string
	switch a1Pos {
	case 1:
		r = v1
	case 2:
		r = v2
	}
	return r

}

// MultOp = "*" | "/"
func (p *CalcParser) stateMultOp() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	a1Pos = 1
	v1, err = p.literal("*")
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("/")
		if err != nil {
			a1Pos = -1
		}
	}
	if err == nil {
		ret = p.Data.actionMultOp(p.pos, a1Pos, v1, v2)
	}

	return ret, err
}

func (p *CalcData) actionMultOp(pos int, a1Pos int, v1 string, v2 string) string {
	var r string
	switch a1Pos {
	case 1:
		r = v1
	case 2:
		r = v2
	}
	return r

}

// Number = [ Neg ] Digit { Digit }
func (p *CalcParser) stateNumber() (int, error) {
	var err error
	var ret int
	var v1 string
	var v2 string
	var v3temp string
	var v3 []string
	// option
	p = p.predict()
	v1, err = p.stateNeg()
	if err != nil {
		p = p.backtrack()
		p.lastErr = err
		err = nil
	} else {
		p = p.accept()
	}
	if err == nil {
		v2, err = p.stateDigit()
		if err == nil {
			// repetition
			for {
				p = p.predict()
				v3temp, err = p.stateDigit()
				if err != nil {
					p = p.backtrack()
					p.lastErr = err
					err = nil
					break
				} else {
					v3 = append(v3, v3temp)
					p = p.accept()
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionNumber(p.pos, v1, v2, v3)
	}

	return ret, err
}

func (p *CalcData) actionNumber(pos int, v1 string, v2 string, v3 []string) int {
	stringNumber := v1 + v2 + strings.Join(v3, "")
	num, _ := strconv.Atoi(stringNumber)
	return num

}

// Neg = "-"
func (p *CalcParser) stateNeg() (string, error) {
	var err error
	var ret string
	var v1 string
	v1, err = p.literal("-")
	if err == nil {
		ret = p.Data.actionNeg(p.pos, v1)
	}

	return ret, err
}

func (p *CalcData) actionNeg(pos int, v1 string) string {
	return v1
}

// Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
func (p *CalcParser) stateDigit() (string, error) {
	var err error
	var ret string
	var a1Pos int
	var v1 string
	var v2 string
	var v3 string
	var v4 string
	var v5 string
	var v6 string
	var v7 string
	var v8 string
	var v9 string
	var v10 string
	a1Pos = 1
	v1, err = p.literal("0")
	if err != nil {
		a1Pos = 2
		v2, err = p.literal("1")
		if err != nil {
			a1Pos = 3
			v3, err = p.literal("2")
			if err != nil {
				a1Pos = 4
				v4, err = p.literal("3")
				if err != nil {
					a1Pos = 5
					v5, err = p.literal("4")
					if err != nil {
						a1Pos = 6
						v6, err = p.literal("5")
						if err != nil {
							a1Pos = 7
							v7, err = p.literal("6")
							if err != nil {
								a1Pos = 8
								v8, err = p.literal("7")
								if err != nil {
									a1Pos = 9
									v9, err = p.literal("8")
									if err != nil {
										a1Pos = 10
										v10, err = p.literal("9")
										if err != nil {
											a1Pos = -1
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionDigit(p.pos, a1Pos, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10)
	}

	return ret, err
}

func (p *CalcData) actionDigit(pos int, a1Pos int, v1 string, v2 string, v3 string, v4 string, v5 string, v6 string, v7 string, v8 string, v9 string, v10 string) string {
	return fmt.Sprintf("%v", a1Pos-1)
}

func ParseCalc(input string, data *CalcData) (int, error) {
	p := newCalcParser(input, data)

	ret, err := p.stateExpression()
	if err == nil {
		if strings.TrimSpace(p.input[p.pos:]) != "" {
			return ret, p.lastErr
		}
	}

	return ret, err
}

type CalcParser struct {
	input       string
	pos         int
	lineOffsets []int
	Data        *CalcData
	lastErr     error

	predictStack []*CalcParser
}

func newCalcParser(input string, data *CalcData) *CalcParser {
	return &CalcParser{
		input:       input,
		lineOffsets: CalcGenerateLineOffsets(input),
		Data:        data,
	}
}

func CalcGenerateLineOffsets(input string) []int {
	var ret []int

	lines := strings.Split(input, "\n")

	offset := 0
	for _, v := range lines {
		ret = append(ret, len(v)+1+offset)
		offset += len(v) + 1
	}
	return ret
}

func (p *CalcParser) position() string {
	for i, v := range p.lineOffsets {
		if p.pos < v {
			return fmt.Sprintf("line %v", i)
		}
	}
	return fmt.Sprintln("impossible line reached", p.pos)
}

func (p *CalcParser) literal(want string) (string, error) {
	count := 0
	for r, s := utf8.DecodeRuneInString(p.input[p.pos+count:]); s > 0 && unicode.IsSpace(r); r, s = utf8.DecodeRuneInString(p.input[p.pos+count:]) {
		count += s
	}

	if strings.HasPrefix(p.input[p.pos+count:], want) {
		p.pos += count + len(want)
		return want, nil
	}

	return "", fmt.Errorf("%v: expected \"%v\"", p.position(), want)
}

func (p *CalcParser) predict() *CalcParser {
	p.predictStack = append(p.predictStack, p)
	return &CalcParser{
		input:        p.input,
		pos:          p.pos,
		lineOffsets:  p.lineOffsets,
		predictStack: p.predictStack,
		lastErr:      p.lastErr,
		Data:         p.Data,
	}
}

func (p *CalcParser) backtrack() *CalcParser {
	pp := p.predictStack[len(p.predictStack)-1]
	pp.predictStack = pp.predictStack[:len(pp.predictStack)-1]
	pp.lastErr = p.lastErr
	return pp
}

func (p *CalcParser) accept() *CalcParser {
	pp := p.backtrack()
	pp.pos = p.pos
	return pp
}
