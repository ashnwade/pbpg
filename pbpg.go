// generated by pbpg, do not modify

package main

import (
	"fmt"
	"log"
	"strings"
	"unicode"
	"unicode/utf8"
)

//  The top level production is the initial state to attempt to reduce.
// Program = [ Comment { Comment } ] [ Header ] Line { Line }
func (p *pbpgParser) stateProgram() (err error) {
	// option
	p = p.predict()
	err = p.stateComment()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			err = p.stateComment()
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				p = p.accept()
			}
		}
	}
	if err != nil {
		p = p.backtrack()
		p.lastErr = err
		err = nil
	} else {
		p = p.accept()
	}
	if err == nil {
		// option
		p = p.predict()
		err = p.stateHeader()
		if err != nil {
			p = p.backtrack()
			p.lastErr = err
			err = nil
		} else {
			p = p.accept()
		}
		if err == nil {
			err = p.stateLine()
			if err == nil {
				// repetition
				for {
					p = p.predict()
					err = p.stateLine()
					if err != nil {
						p = p.backtrack()
						p.lastErr = err
						err = nil
						break
					} else {
						p = p.accept()
					}
				}
			}
		}
	}
	return err
}

// Header = "{" Code "}"
func (p *pbpgParser) stateHeader() (err error) {
	err = p.literal("{")
	if err == nil {
		err = p.stateCode()
		if err == nil {
			err = p.literal("}")
		}
	}
	if err == nil {
		p.Data.actionHeader(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionHeader(whitespace bool, lit, lex string) {
	p.out.WriteString(doNotModify)
	p.out.WriteString(p.popCode())
}

// Line = Comment | Production
func (p *pbpgParser) stateLine() (err error) {
	err = p.stateComment()
	if err != nil {
		err = p.stateProduction()
	}
	return err
}

// Production = Name "=" [ Expression ] "." [ Action ] [ Error ]
func (p *pbpgParser) stateProduction() (err error) {
	err = p.stateName()
	if err == nil {
		err = p.literal("=")
		if err == nil {
			// option
			p = p.predict()
			err = p.stateExpression()
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
			} else {
				p = p.accept()
			}
			if err == nil {
				err = p.literal(".")
				if err == nil {
					// option
					p = p.predict()
					err = p.stateAction()
					if err != nil {
						p = p.backtrack()
						p.lastErr = err
						err = nil
					} else {
						p = p.accept()
					}
					if err == nil {
						// option
						p = p.predict()
						err = p.stateError()
						if err != nil {
							p = p.backtrack()
							p.lastErr = err
							err = nil
						} else {
							p = p.accept()
						}
					}
				}
			}
		}
	}
	if err == nil {
		p.Data.actionProduction(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionProduction(whitespace bool, lit, lex string) {
	if p.stateMap == nil {
		p.stateMap = make(map[string]*Expression)
	}
	name := p.popName()
	if p.stateMap[name] != nil {
		log.Fatalf("%v redeclared", name)
	}
	p.stateMap[name] = p.expression

	p.emitState(name, p.expression, p.sAction, p.sError)
	p.expression = nil
	p.sAction = ""
	p.sError = ""

	if p.entryPoint == "" {
		p.entryPoint = name
	}

}

// Action = "Action" CodeBlock
func (p *pbpgParser) stateAction() (err error) {
	err = p.literal("Action")
	if err == nil {
		err = p.stateCodeBlock()
	}
	if err == nil {
		p.Data.actionAction(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionAction(whitespace bool, lit, lex string) {
	p.sAction = p.popCode()
}

// Error = "Error" CodeBlock
func (p *pbpgParser) stateError() (err error) {
	err = p.literal("Error")
	if err == nil {
		err = p.stateCodeBlock()
	}
	if err == nil {
		p.Data.actionError(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionError(whitespace bool, lit, lex string) {
	p.sError = p.popCode()
}

// CodeBlock = "{" Code "}"
func (p *pbpgParser) stateCodeBlock() (err error) {
	err = p.literal("{")
	if err == nil {
		err = p.stateCode()
		if err == nil {
			err = p.literal("}")
		}
	}
	return err
}

// Expression = Alternative { "|" Alternative }
func (p *pbpgParser) stateExpression() (err error) {
	err = p.stateAlternative()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			err = p.literal("|")
			if err == nil {
				err = p.stateAlternative()
			}
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				p = p.accept()
			}
		}
	}
	if err == nil {
		p.Data.actionExpression(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionExpression(whitespace bool, lit, lex string) {
	p.expression = &Expression{
		alternatives: p.alternatives,
	}
	p.alternatives = nil

}

// Alternative = Term { Term }
func (p *pbpgParser) stateAlternative() (err error) {
	err = p.stateTerm()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			err = p.stateTerm()
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				p = p.accept()
			}
		}
	}
	if err == nil {
		p.Data.actionAlternative(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionAlternative(whitespace bool, lit, lex string) {
	p.alternatives = append(p.alternatives, &Alternative{terms: p.terms})
	p.terms = nil

}

// Term = Lex | Name | Literal | Group | Option | Repetition
func (p *pbpgParser) stateTerm() (err error) {
	err = p.stateLex()
	if err != nil {
		err = p.stateName()
		if err != nil {
			err = p.stateLiteral()
			if err != nil {
				err = p.stateGroup()
				if err != nil {
					err = p.stateOption()
					if err != nil {
						err = p.stateRepetition()
					}
				}
			}
		}
	}
	if err == nil {
		p.Data.actionTerm(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionTerm(whitespace bool, lit, lex string) {
	t := &Term{option: p.popLastTerm()}
	switch t.option {
	case TERM_NAME:
		t.name = p.popName()
	case TERM_LEX:
		t.lex = p.popName()
	case TERM_GOR:
		t.gor = p.popGOR()
	case TERM_LITERAL:
		t.literal = p.popLiteral()
	}
	p.terms = append(p.terms, t)

}

// Group = "(" Expression ")"
func (p *pbpgParser) stateGroup() (err error) {
	err = p.literal("(")
	if err == nil {
		err = p.stateExpression()
		if err == nil {
			err = p.literal(")")
		}
	}
	if err == nil {
		p.Data.actionGroup(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionGroup(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_GOR)
	p.pushGOR(&GOR{option: GOR_GROUP, expression: p.expression})
	p.expression = nil

}

// Option = "[" Expression "]"
func (p *pbpgParser) stateOption() (err error) {
	err = p.literal("[")
	if err == nil {
		err = p.stateExpression()
		if err == nil {
			err = p.literal("]")
		}
	}
	if err == nil {
		p.Data.actionOption(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionOption(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_GOR)
	p.pushGOR(&GOR{option: GOR_OPTION, expression: p.expression})
	p.expression = nil

}

// Repetition = "{" Expression "}"
func (p *pbpgParser) stateRepetition() (err error) {
	err = p.literal("{")
	if err == nil {
		err = p.stateExpression()
		if err == nil {
			err = p.literal("}")
		}
	}
	if err == nil {
		p.Data.actionRepetition(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionRepetition(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_GOR)
	p.pushGOR(&GOR{option: GOR_REPETITION, expression: p.expression})
	p.expression = nil

}

// Lex = "lex" "(" LexFunction ")"
func (p *pbpgParser) stateLex() (err error) {
	err = p.literal("lex")
	if err == nil {
		err = p.literal("(")
		if err == nil {
			err = p.stateLexFunction()
			if err == nil {
				err = p.literal(")")
			}
		}
	}
	if err == nil {
		p.Data.actionLex(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionLex(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_LEX)

}

// Literal = """ String """
func (p *pbpgParser) stateLiteral() (err error) {
	err = p.literal("\"")
	if err == nil {
		err = p.stateString()
		if err == nil {
			err = p.literal("\"")
		}
	}
	if err == nil {
		p.Data.actionLiteral(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionLiteral(whitespace bool, lit, lex string) {
	p.pushLiteral(p.popString())
}

//  Lexer directives.
// Code = code
func (p *pbpgParser) stateCode() (err error) {
	{
		n, lexeme, lerr := p.Data.lexcode(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			p.lexeme = lexeme
		}
	}
	if err == nil {
		p.Data.actionCode(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionCode(whitespace bool, lit, lex string) {
	p.pushCode(lex)
}

// Comment = "#" comment
func (p *pbpgParser) stateComment() (err error) {
	err = p.literal("#")
	if err == nil {
		{
			n, lexeme, lerr := p.Data.lexcomment(p.input[p.pos:])
			p.pos += n
			if lerr != nil {
				err = fmt.Errorf("%v: %w", p.position(), lerr)
			} else {
				err = nil
				p.lexeme = lexeme
			}
		}
	}
	if err == nil {
		p.Data.actionComment(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionComment(whitespace bool, lit, lex string) {
	p.out.WriteString("// " + lex + "\n")
}

// Name = name
func (p *pbpgParser) stateName() (err error) {
	{
		n, lexeme, lerr := p.Data.lexname(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			p.lexeme = lexeme
		}
	}
	if err == nil {
		p.Data.actionName(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionName(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_NAME)
	p.pushName(lex)
}

// LexFunction = functionname
func (p *pbpgParser) stateLexFunction() (err error) {
	{
		n, lexeme, lerr := p.Data.lexfunctionname(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			p.lexeme = lexeme
		}
	}
	if err == nil {
		p.Data.actionLexFunction(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionLexFunction(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_NAME)
	p.pushName(lex)
}

// String = string
func (p *pbpgParser) stateString() (err error) {
	{
		n, lexeme, lerr := p.Data.lexstring(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			p.lexeme = lexeme
		}
	}
	if err == nil {
		p.Data.actionString(p.lastWhitespace, p.lastLiteral, p.lexeme)
	}

	return err
}

func (p *pbpgData) actionString(whitespace bool, lit, lex string) {
	p.pushLastTerm(TERM_LITERAL)
	p.pushString(lex)
}

func Parsepbpg(input string) (*pbpgParser, error) {
	p := newpbpgParser(input)

	err := p.stateProgram()
	if err == nil {
		if strings.TrimSpace(p.input[p.pos:]) != "" {
			return p, p.lastErr
		}
	}
	return p, err
}

type pbpgParser struct {
	input          string
	pos            int
	lineOffsets    []int
	lexeme         string
	Data           *pbpgData
	lastErr        error
	lastLiteral    string
	lastWhitespace bool

	predictStack []*pbpgParser
}

func newpbpgParser(input string) *pbpgParser {
	return &pbpgParser{
		input:       input,
		lineOffsets: pbpgGenerateLineOffsets(input),
		Data:        &pbpgData{},
	}
}

func pbpgGenerateLineOffsets(input string) []int {
	var ret []int

	lines := strings.Split(input, "\n")

	offset := 0
	for _, v := range lines {
		ret = append(ret, len(v)+1+offset)
		offset += len(v) + 1
	}
	return ret
}

func (p *pbpgParser) position() string {
	for i, v := range p.lineOffsets {
		if p.pos < v {
			return fmt.Sprintf("line %v", i)
		}
	}
	return fmt.Sprintln("impossible line reached", p.pos)
}

func (p *pbpgParser) literal(want string) error {
	count := 0
	for r, s := utf8.DecodeRuneInString(p.input[p.pos+count:]); s > 0 && unicode.IsSpace(r); r, s = utf8.DecodeRuneInString(p.input[p.pos+count:]) {
		count += s
	}

	if strings.HasPrefix(p.input[p.pos+count:], want) {
		p.pos += count + len(want)
		p.lastLiteral = want
		p.lastWhitespace = count > 0
		return nil
	}

	return fmt.Errorf("%v: expected \"%v\"", p.position(), want)
}

func (p *pbpgParser) predict() *pbpgParser {
	p.predictStack = append(p.predictStack, p)
	return &pbpgParser{
		input:        p.input,
		pos:          p.pos,
		lineOffsets:  p.lineOffsets,
		lexeme:       p.lexeme,
		Data:         p.Data.fork(),
		predictStack: p.predictStack,
		lastErr:      p.lastErr,
	}
}

func (p *pbpgParser) backtrack() *pbpgParser {
	pp := p.predictStack[len(p.predictStack)-1]
	pp.predictStack = pp.predictStack[:len(pp.predictStack)-1]
	pp.lastErr = p.lastErr
	return pp
}

func (p *pbpgParser) accept() *pbpgParser {
	pp := p.backtrack()
	pp.pos = p.pos
	pp.lexeme = p.lexeme
	pp.Data.merge(p.Data)
	return pp
}
