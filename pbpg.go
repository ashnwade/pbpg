// generated by pbpg, do not modify

package main

import (
	"fmt"
	"log"
	"strings"
	"unicode"
	"unicode/utf8"
)

//  The top level production is the initial state to attempt to reduce.
// Program = [ Comment { Comment } ] [ Header ] { Types } Line { Line }
func (p *pbpgParser) stateProgram() (err error) {
	// option
	p = p.predict()
	err = p.stateComment()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			err = p.stateComment()
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				p = p.accept()
			}
		}
	}
	if err != nil {
		p = p.backtrack()
		p.lastErr = err
		err = nil
	} else {
		p = p.accept()
	}
	if err == nil {
		// option
		p = p.predict()
		err = p.stateHeader()
		if err != nil {
			p = p.backtrack()
			p.lastErr = err
			err = nil
		} else {
			p = p.accept()
		}
		if err == nil {
			// repetition
			for {
				p = p.predict()
				err = p.stateTypes()
				if err != nil {
					p = p.backtrack()
					p.lastErr = err
					err = nil
					break
				} else {
					p = p.accept()
				}
			}
			if err == nil {
				err = p.stateLine()
				if err == nil {
					// repetition
					for {
						p = p.predict()
						err = p.stateLine()
						if err != nil {
							p = p.backtrack()
							p.lastErr = err
							err = nil
							break
						} else {
							p = p.accept()
						}
					}
				}
			}
		}
	}
	return err
}

// Header = CodeBlock
func (p *pbpgParser) stateHeader() (err error) {
	var v1 string
	v1, err = p.stateCodeBlock()
	if err == nil {
		p.Data.actionHeader(v1)
	}

	return err
}

func (p *pbpgData) actionHeader(v1 string) {
	p.out.WriteString(doNotModify)
	p.out.WriteString(v1)
}

// Types = "type" String String
func (p *pbpgParser) stateTypes() (err error) {
	var v1 string
	var v2 string
	var v3 string
	v1, err = p.literal("type")
	if err == nil {
		v2, err = p.stateName()
		if err == nil {
			{
				n, lexeme, lerr := p.Data.lextype(p.input[p.pos:])
				p.pos += n
				if lerr != nil {
					err = fmt.Errorf("%v: %w", p.position(), lerr)
				} else {
					err = nil
					v3 = lexeme
				}
			}
		}
	}
	if err == nil {
		p.Data.actionTypes(v1, v2, v3)

	}

	return err
}

func (p *pbpgData) actionTypes(v1, v2, v3 string) {
	if _, ok := p.typeMap[v2]; ok {
		log.Fatalf("type %v redeclared", v2)
	}
	p.typeMap[v2] = v3

}

// Line = Comment | Production
func (p *pbpgParser) stateLine() (err error) {
	err = p.stateComment()
	if err != nil {
		err = p.stateProduction()
	}
	return err
}

// Production = Name "=" [ Expression ] "." [ Action ] [ Error ]
func (p *pbpgParser) stateProduction() (err error) {
	var v1 string
	var v2 string
	var v3 *Expression
	var v4 string
	var v5 string
	var v6 string

	v1, err = p.stateName()
	if err == nil {
		v2, err = p.literal("=")
		if err == nil {
			// option
			p = p.predict()
			v3, err = p.stateExpression()
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
			} else {
				p = p.accept()
			}
			if err == nil {
				v4, err = p.literal(".")
				if err == nil {
					// option
					p = p.predict()
					v5, err = p.stateAction()
					if err != nil {
						p = p.backtrack()
						p.lastErr = err
						err = nil
					} else {
						p = p.accept()
					}
					if err == nil {
						// option
						p = p.predict()
						v6, err = p.stateError()
						if err != nil {
							p = p.backtrack()
							p.lastErr = err
							err = nil
						} else {
							p = p.accept()
						}
					}
				}
			}
		}
	}
	if err == nil {
		p.Data.actionProduction(v1, v2, v3, v4, v5, v6)
	}

	return err
}

func (p *pbpgData) actionProduction(v1 string, v2 string, v3 *Expression, v4 string, v5 string, v6 string) {
	if p.stateMap[v1] != nil {
		log.Fatalf("%v redeclared", v1)
	}
	p.stateMap[v1] = v3

	p.emitState(v1, v3, v5, v6)

	if p.entryPoint == "" {
		p.entryPoint = v1
	}

}

// Action = "Action" CodeBlock
func (p *pbpgParser) stateAction() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string

	v1, err = p.literal("Action")
	if err == nil {
		v2, err = p.stateCodeBlock()
	}
	if err == nil {
		ret = p.Data.actionAction(v1, v2)
	}

	return ret, err
}

func (p *pbpgData) actionAction(v1, v2 string) string {
	return v2
}

// Error = "Error" CodeBlock
func (p *pbpgParser) stateError() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string

	v1, err = p.literal("Error")
	if err == nil {
		v2, err = p.stateCodeBlock()
	}
	if err == nil {
		ret = p.Data.actionError(v1, v2)
	}

	return ret, err
}

func (p *pbpgData) actionError(v1, v2 string) string {
	return v2
}

// CodeBlock = "{" Code "}"
func (p *pbpgParser) stateCodeBlock() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	var v3 string

	v1, err = p.literal("{")
	if err == nil {
		v2, err = p.stateCode()
		if err == nil {
			v3, err = p.literal("}")
		}
	}
	if err == nil {
		ret = p.Data.actionCodeBlock(v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionCodeBlock(v1 string, v2 string, v3 string) string {
	return v2
}

// Expression = Alternative { "|" Alternative }
func (p *pbpgParser) stateExpression() (*Expression, error) {
	var err error
	var ret *Expression
	var v1 *Alternative
	var v2 []string
	var v2temp string
	var v3 []*Alternative
	var v3temp *Alternative

	v1, err = p.stateAlternative()
	if err == nil {
		// repetition
		for {
			p = p.predict()

			v2temp, err = p.literal("|")
			if err == nil {
				v3temp, err = p.stateAlternative()
			}
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				v2 = append(v2, v2temp)
				v3 = append(v3, v3temp)
				p = p.accept()
			}
		}
	}
	if err == nil {
		ret = p.Data.actionExpression(v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionExpression(v1 *Alternative, v2 []string, v3 []*Alternative) *Expression {
	return &Expression{alternatives: append([]*Alternative{v1}, v3...)}
}

// Alternative = Term { Term }
func (p *pbpgParser) stateAlternative() (*Alternative, error) {
	var err error
	var ret *Alternative
	var v1 *Term
	var v2 []*Term
	var v2temp *Term

	v1, err = p.stateTerm()
	if err == nil {
		// repetition
		for {
			p = p.predict()
			v2temp, err = p.stateTerm()
			if err != nil {
				p = p.backtrack()
				p.lastErr = err
				err = nil
				break
			} else {
				p = p.accept()
				v2 = append(v2, v2temp)
			}
		}
	}
	if err == nil {
		ret = p.Data.actionAlternative(v1, v2)
	}

	return ret, err
}

func (p *pbpgData) actionAlternative(v1 *Term, v2 []*Term) *Alternative {
	return &Alternative{terms: append([]*Term{v1}, v2...)}
}

// Term = Lex | Name | Literal | Group | Option | Repetition
func (p *pbpgParser) stateTerm() (*Term, error) {
	var err error
	var ret *Term
	var v1pos int
	var v1 interface{}

	v1pos = 1
	v1, err = p.stateLex()
	if err != nil {
		v1pos = 2
		v1, err = p.stateName()
		if err != nil {
			v1pos = 3
			v1, err = p.stateLiteral()
			if err != nil {
				v1pos = 4
				v1, err = p.stateGroup()
				if err != nil {
					v1pos = 5
					v1, err = p.stateOption()
					if err != nil {
						v1pos = 6
						v1, err = p.stateRepetition()
					}
				}
			}
		}
	}
	if err == nil {
		ret = p.Data.actionTerm(v1pos, v1)
	}

	return ret, err
}

func (p *pbpgData) actionTerm(v1pos int, v1 interface{}) *Term {
	t := &Term{}
	switch v1pos {
	case 1:
		t.lex = v1.(string)
		t.option = TERM_LEX
	case 2:
		t.name = v1.(string)
		t.option = TERM_NAME
	case 3:
		t.literal = v1.(string)
		t.option = TERM_LITERAL
	case 4, 5, 6:
		t.gor = v1.(*GOR)
		t.option = TERM_GOR
	}
	return t

}

// Group = "(" Expression ")"
func (p *pbpgParser) stateGroup() (*GOR, error) {
	var err error
	var ret *GOR
	var v1 string
	var v2 *Expression
	var v3 string

	v1, err = p.literal("(")
	if err == nil {
		v2, err = p.stateExpression()
		if err == nil {
			v3, err = p.literal(")")
		}
	}
	if err == nil {
		ret = p.Data.actionGroup(v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionGroup(v1 string, v2 *Expression, v3 string) *GOR {
	return &GOR{option: GOR_GROUP, expression: v2}
}

// Option = "[" Expression "]"
func (p *pbpgParser) stateOption() (*GOR, error) {
	var err error
	var ret *GOR
	var v1 string
	var v2 *Expression
	var v3 string

	v1, err = p.literal("[")
	if err == nil {
		v2, err = p.stateExpression()
		if err == nil {
			v3, err = p.literal("]")
		}
	}
	if err == nil {
		ret = p.Data.actionOption(v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionOption(v1 string, v2 *Expression, v3 string) *GOR {
	return &GOR{option: GOR_OPTION, expression: v2}
}

// Repetition = "{" Expression "}"
func (p *pbpgParser) stateRepetition() (*GOR, error) {
	var err error
	var ret *GOR
	var v1 string
	var v2 *Expression
	var v3 string

	v1, err = p.literal("{")
	if err == nil {
		v2, err = p.stateExpression()
		if err == nil {
			v3, err = p.literal("}")
		}
	}
	if err == nil {
		ret = p.Data.actionRepetition(v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionRepetition(v1 string, v2 *Expression, v3 string) *GOR {
	return &GOR{option: GOR_REPETITION, expression: v2}
}

// Lex = "lex" "(" String ")"
func (p *pbpgParser) stateLex() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	var v3 string
	var v4 string

	v1, err = p.literal("lex")
	if err == nil {
		v2, err = p.literal("(")
		if err == nil {
			{
				n, lexeme, lerr := p.Data.lexname(p.input[p.pos:])
				p.pos += n
				if lerr != nil {
					err = fmt.Errorf("%v: %w", p.position(), lerr)
				} else {
					err = nil
					v3 = lexeme
				}
			}
			if err == nil {
				v4, err = p.literal(")")
			}
		}
	}
	if err == nil {
		ret = p.Data.actionLex(v1, v2, v3, v4)
	}

	return ret, err
}

func (p *pbpgData) actionLex(v1, v2, v3, v4 string) string {
	return v3
}

// Literal = """ String """
func (p *pbpgParser) stateLiteral() (string, error) {
	var err error
	var ret string
	var v1 string
	var v2 string
	var v3 string

	v1, err = p.literal("\"")
	if err == nil {
		v2, err = p.stateQuotedString()
		if err == nil {
			v3, err = p.literal("\"")
		}
	}
	if err == nil {
		ret = p.Data.actionLiteral(v1, v2, v3)
	}

	return ret, err
}

func (p *pbpgData) actionLiteral(v1, v2, v3 string) string {
	return v2
}

// Name = String
func (p *pbpgParser) stateName() (string, error) {
	var err error
	var ret string
	var v1 string
	{
		n, lexeme, lerr := p.Data.lexname(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			v1 = lexeme
		}
	}
	if err == nil {
		ret = p.Data.actionName(v1)
	}

	return ret, err
}

func (p *pbpgData) actionName(v1 string) string {
	return v1
}

//  Lexer directives.
// Code = code
func (p *pbpgParser) stateCode() (string, error) {
	var err error
	var ret string
	var v1 string
	{
		n, lexeme, lerr := p.Data.lexcode(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			v1 = lexeme
		}
	}
	if err == nil {
		ret = p.Data.actionCode(v1)
	}

	return ret, err
}

func (p *pbpgData) actionCode(v1 string) string {
	return v1
}

// String = string
func (p *pbpgParser) stateQuotedString() (string, error) {
	var err error
	var ret string
	var v1 string
	{
		n, lexeme, lerr := p.Data.lexquotedstring(p.input[p.pos:])
		p.pos += n
		if lerr != nil {
			err = fmt.Errorf("%v: %w", p.position(), lerr)
		} else {
			err = nil
			v1 = lexeme
		}
	}
	if err == nil {
		ret = p.Data.actionString(v1)
	}

	return ret, err
}

func (p *pbpgData) actionString(v1 string) string {
	return v1
}

// Comment = "#" comment
func (p *pbpgParser) stateComment() (err error) {
	var v1 string
	var v2 string
	v1, err = p.literal("#")
	if err == nil {
		{
			n, lexeme, lerr := p.Data.lexcomment(p.input[p.pos:])
			p.pos += n
			if lerr != nil {
				err = fmt.Errorf("%v: %w", p.position(), lerr)
			} else {
				err = nil
				v2 = lexeme
			}
		}
	}
	if err == nil {
		p.Data.actionComment(v1, v2)
	}

	return err
}

func (p *pbpgData) actionComment(v1, v2 string) {
	p.out.WriteString("// " + v2 + "\n")
}

func Parsepbpg(input string, data *pbpgData) error {
	p := newpbpgParser(input, data)

	err := p.stateProgram()
	if err == nil {
		if strings.TrimSpace(p.input[p.pos:]) != "" {
			return p.lastErr
		}
	}
	return err
}

type pbpgParser struct {
	input       string
	pos         int
	lineOffsets []int
	Data        *pbpgData
	lastErr     error

	predictStack []*pbpgParser
}

func newpbpgParser(input string, data *pbpgData) *pbpgParser {
	return &pbpgParser{
		input:       input,
		lineOffsets: pbpgGenerateLineOffsets(input),
		Data:        data,
	}
}

func pbpgGenerateLineOffsets(input string) []int {
	var ret []int

	lines := strings.Split(input, "\n")

	offset := 0
	for _, v := range lines {
		ret = append(ret, len(v)+1+offset)
		offset += len(v) + 1
	}
	return ret
}

func (p *pbpgParser) position() string {
	for i, v := range p.lineOffsets {
		if p.pos < v {
			return fmt.Sprintf("line %v", i)
		}
	}
	return fmt.Sprintln("impossible line reached", p.pos)
}

func (p *pbpgParser) literal(want string) (string, error) {
	count := 0
	for r, s := utf8.DecodeRuneInString(p.input[p.pos+count:]); s > 0 && unicode.IsSpace(r); r, s = utf8.DecodeRuneInString(p.input[p.pos+count:]) {
		count += s
	}

	if strings.HasPrefix(p.input[p.pos+count:], want) {
		p.pos += count + len(want)
		return want, nil
	}

	return "", fmt.Errorf("%v: expected \"%v\"", p.position(), want)
}

func (p *pbpgParser) predict() *pbpgParser {
	p.predictStack = append(p.predictStack, p)
	return &pbpgParser{
		input:        p.input,
		pos:          p.pos,
		lineOffsets:  p.lineOffsets,
		predictStack: p.predictStack,
		Data:         p.Data,
		lastErr:      p.lastErr,
	}
}

func (p *pbpgParser) backtrack() *pbpgParser {
	pp := p.predictStack[len(p.predictStack)-1]
	pp.predictStack = pp.predictStack[:len(pp.predictStack)-1]
	pp.lastErr = p.lastErr
	return pp
}

func (p *pbpgParser) accept() *pbpgParser {
	pp := p.backtrack()
	pp.pos = p.pos
	return pp
}
